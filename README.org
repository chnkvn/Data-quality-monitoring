#+TITLE: Data Quality Monitoring
#+autotangle: t
* Data Creation
- The first part of this project is to create fake data
- It should be requestable with an API
** Sensor
*** class definition :noexport:
#+begin_src python :tangle src/sensor.py
import sys
from datetime import date, timedelta
import numpy as np
from attrs import define, field

@define
class Sensor:
    """Create a sensor that returns the number
    of visitors given a date and an hour."""

    avg_visit:int = field(converter=int)
    std_visit:float = field(converter=float)
    perc_break: float = field(converter=float, default=0.015)
    perc_malfunction: float = field(converter=float, default=0.035)
    open_hours = list(range(9, 22))

#+end_src
*** simulate_visit_count_method :noexport:
#+begin_src python :tangle src/sensor.py
    def simulate_visit_count(self, business_date: date) -> int:
        """Simulate the number of person detected by the sensor given a date and an hour"""

        # For reprocubility
        np.random.seed(seed=business_date.toordinal())

        # Get weekday of the business day
        weekday = business_date.weekday()

        # Generate the visitor counts over the working hours
        visits = np.random.normal(
            self.avg_visit, self.std_visit, size=len(self.open_hours)
        ) / len(self.open_hours)

        # More traffic on wednesdays (2), fridays (4), saturdays (5)
        if weekday == 2:
            visits *= 1.15
        elif weekday == 4:
            visits *= 1.2
        elif weekday == 5:
            visits *= 1.35
        # visitor count is set to -1 on sundays
        elif weekday == 6:
            visits *= 0
            visits -= 1
        return visits
#+end_src

*** get_visit_count method :noexport:
#+begin_src python :tangle src/sensor.py
    def get_visit_count(self, business_date:date, hour:int) -> int:
        """Returns the number of visitors from the store opening hour to the hour passed in parameters."""
        #For reprocubility
        np.random.seed(seed=business_date.toordinal())

        visitors_count = 0
        proba_malfunction = np.random.random()

        # The sensor can break sometimes
        # Also return 0 when hour in closing hours
        if proba_malfunction < self.perc_break or hour not in self.open_hours:
           return visitors_count
        if business_date.weekday() == 6:
           return -1
        visits = self.simulate_visit_count(business_date)
        # The sensor can also malfunction
        if proba_malfunction < self.perc_malfunction:
            visits *= 0.2  # make it so bad we can detect it ;)
        visits = np.floor(visits)
        for hour_, visit_count in zip(self.open_hours, visits):
                visitors_count += visit_count
                if hour_==hour:
                        break
        return int(visitors_count)
#+end_src
*** __main__ :noexport:
#+begin_src python :tangle src/sensor.py
if __name__ == "__main__":
    if len(sys.argv) > 2:
        year, month, day = [int(v) for v in sys.argv[1].split("-")]
        hour = int(sys.argv[2])
    else:
        year, month, day = 2023, 10, 25
        hour = 18
    queried_date = date(year, month, day)

    captor = Sensor(1500, 150)
    print(captor.get_visit_count(queried_date, hour))
#+end_src
** Store
*** class definition :noexport:
#+begin_src python :tangle src/store.py
from datetime import date

import numpy as np
from attrs import define, field
from data_quality_monitoring.src.sensor import Sensor

@define
class Store:
    name:str = field(converter=str)
    avg_visit: int = field(converter=int)
    std_visit: float = field(converter=float)
    perc_malfunction:float = field(default=0)
    perc_break:float = field(default=0)
    sensors = field(init=False)

    def __attrs_post_init__(self):
        # To always get the same result when asking for the same store
        seed = np.sum(list(self.name.encode("ascii")))
        np.random.seed(seed=seed)
        # Let assume every store has 5 captors
        traffic_percentage = {0.49, 0.31, 0.1, 0.07, 0.03}
        self.sensors = [
            Sensor(percent * self.avg_visit,
                   percent* self.std_visit,
                   self.perc_break,
                   self.perc_malfunction)
            for percent in traffic_percentage
        ]
#+end_src
*** get sensor traffic :noexport:
#+begin_src python :tangle src/store.py
    def get_sensor_traffic(self, sensor_id : int, requested_date:date, hour:int) -> int:
        """Return the traffic of a sensor given a date and an hour"""
        return self.sensors[sensor_id].get_visit_count(requested_date, hour)
#+end_src
*** get store traffic :noexport:
#+begin_src python :tangle src/store.py
    def get_store_traffic(self, requested_date:date, hour:int) -> int:
        """Return the traffic of all the sensors given a date and an hour"""
        traffic = sum(sensor.get_visit_count(requested_date, hour) for sensor in self.sensors)
        return traffic
#+end_src
*** __main__ :noexport:
#+begin_src python :tangle src/store.py
if __name__ == '__main__':
    lille_store = Store("Test", 1200, 300)
    visits = lille_store.get_store_traffic(date(2023, 12, 21), 18)
    print(visits)
#+end_src
** init :noexport:
#+begin_src python :tangle __init__.py
from datetime import date

from data_quality_monitoring.src.store import Store


def create_data() -> dict:
    """
    Create the available stores in our API
    5 stores, with each 5 sensors
    Each stores has a different number of people coming to it
    As well as different break and malfunction percentages
    (Not realistic, but we keep things simple)
    """

    store_name = ["Nancy", "Paris", "Lille", "Cholet", "Cabourg"]
    store_avg_visit = [3000, 8000, 6000, 2000, 1700]
    store_std_visit = [500, 800, 500, 400, 100]
    perc_malfunction = [0.05, 0.1, 0.08, 0.05, 0.05]
    perc_break = [0.05, 0.08, 0.05, 0.02, 0]

    store_dict = {tuple_[0]: Store(*tuple_)
                  for tuple_  in zip(store_name,
                                     store_avg_visit,
                                     store_std_visit,
                                     perc_break,
                                     perc_malfunction)}

    return store_dict

if __name__ == '__main__':
    print(create_data())

#+end_src


** Unit tests :noexport:
*** sensors

#+begin_src python :tangle tests/test_sensors.py
import unittest
from datetime import date

import numpy as np
from data_quality_monitoring.src.sensor import Sensor

class TestVisitSensor(unittest.TestCase):
    def test_weekdays_open(self):
        for test_day in range(11, 17):
            with self.subTest(i=test_day):
                visit_sensor = Sensor(1200, 300)
                visit_count = visit_sensor.simulate_visit_count(date(2023, 9, test_day))
                self.assertFalse(-1 in set(visit_count))

    def test_sunday_closed(self):
        visit_sensor = Sensor(1200, 300)
        visit_count = visit_sensor.simulate_visit_count(date(2023, 9, 17))
        self.assertEqual(set(visit_count), {-1})

    def test_with_break(self):
        visit_sensor = Sensor(1500, 150, perc_break=15)
        visit_count = visit_sensor.get_visit_count(date(2023, 10, 12), 20)
        self.assertEqual(visit_count, 0)

    def test_with_malfunction(self):
        visit_sensor = Sensor(1500, 150, perc_malfunction=15)
        visit_count = visit_sensor.get_visit_count(date(2023, 10, 12), 20)
        self.assertEqual(visit_count, 276)


if __name__ == "__main__":
    unittest.main()
#+end_src

*** store
#+begin_src python :tangle tests/test_store.py
import unittest
from datetime import date

from data_quality_monitoring.src.store import Store


class TestStore(unittest.TestCase):
    def test_get_store_traffic(self):
        lille_store = Store("Test", 1200, 300)
        visits = lille_store.get_store_traffic(date(2023, 12, 21), 18)

        self.assertEqual(visits, 880)

    def test_get_sensor_traffic(self):
        lille_store = Store("Test", 1200, 300)
        visits = lille_store.get_sensor_traffic(3, date(2023, 12, 21), 18)

        self.assertEqual(visits, 276)

    def test_sunday_closed(self):
        lille_store = Store("Test", 1200, 300)
        visits = lille_store.get_sensor_traffic(2, date(2024, 1, 7), 18)
        self.assertEqual(visits, -1)


if __name__ == "__main__":
    unittest.main()
#+end_src

* API
- Creation of an api with FastAPI
- We create it to simulate the provider's API, here the API is deployed locally.
To launch the api locally, run ~uvicorn app:app --reload~
#+begin_src python :tangle app.py
import logging
from datetime import date

from fastapi import FastAPI
from fastapi.responses import JSONResponse
from data_quality_monitoring import create_data

store_dict = create_data()
app = FastAPI()


@app.get("/")
def get_nb_visitors(store_name: str="Nancy", year: int=2021, month: int=1, day: int=25,  hour: int = 21, sensor_id: int | None = None) -> JSONResponse:
    # Check the year
    if year < 2020:
        return JSONResponse(status_code=404, content="No data before 2020")

    # Check the date
    try:
        requested_date = date(year, month, day)
    except ValueError as e:
        logging.error(f"Could not cast date: {e}")
        return JSONResponse(status_code=404, content="Enter a valid date")

    # Check the date is in the past
    if date.today() < requested_date:
        return JSONResponse(status_code=404, content="Choose a date in the past")
    # If no sensor choose return the visit for the whole store
    if hour > max(store_dict[store_name].sensors[0].open_hours):
        hour =  21
    if sensor_id is None:
        visit_counts = store_dict[store_name].get_store_traffic(requested_date, hour)
    elif sensor_id not in range(len(store_dict[store_name].sensors)):
         return JSONResponse(status_code=404,
                             content=(f"Sensor #{sensor_id} does not exist. "
                             f"This store only have {len(store_dict[store_name].sensors)} sensors."))
    else:
        visit_counts = store_dict[store_name].get_sensor_traffic(
            sensor_id, requested_date, hour
        )
    if visit_counts < 0 or hour < min(store_dict[store_name].sensors[0].open_hours):
        return JSONResponse(
            status_code=404, content="The store was closed try another date or hour."
        )
    return JSONResponse(status_code=200, content=visit_counts)
#+end_src

* Data Extraction
The goal is to request the API to build our data
#+begin_src python :tangle data_extraction.py
import sys
from datetime import date

import requests

year, month, day = [int(v) for v in sys.argv[1].split("-")]
date_ = date(year, month, day)
assert type(date_) == date
print(date_.year, type(date_.year))
def request_api(day:date = date_, hour=21, url="http://127.0.0.1:8000/"):
    """Request information from an API"""
    params = {'year':day.year,
              "month":day.month,
              "day":day.day,
              "hour":hour}
    r = requests.get(url, params=params)
    return r.content
print(request_api(date_, 7))
#+end_src
