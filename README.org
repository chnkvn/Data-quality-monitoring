#+TITLE: Data Quality Monitoring
#+autotangle: t
* Data Creation
- The first part of this project is to create fake data
- It should be requestable with an API
** main functions
*** class definition :noexport:
#+begin_src python :tangle src/sensor.py
import sys
from datetime import date, timedelta
import numpy as np
from attrs import define, field

@define
class Sensor:
    """Create a sensor that returns the number
    of visitors given a date and an hour."""

    avg_visit = field(converter=int)
    std_visit = field(converter=float)
    perc_break: float = field(converter=float, default=0.015)
    perc_malfunction: float = field(converter=float, default=0.035)
    open_hours = list(range(9, 22))

#+end_src
*** simulate_visit_count_method :noexport:
#+begin_src python :tangle src/sensor.py
    def simulate_visit_count(self, business_date: date) -> int:
        """Simulate the number of person detected by the sensor given a date and an hour"""

        # For reprocubility
        np.random.seed(seed=business_date.toordinal())

        # Get weekday of the business day
        weekday = business_date.weekday()

        # Generate the visitor counts over the working hours
        visits = np.random.normal(
            self.avg_visit, self.std_visit, size=len(self.open_hours)
        ) / len(self.open_hours)

        # More traffic on wednesdays (2), fridays (4), saturdays (5)
        if weekday == 2:
            visits *= 1.15
        elif weekday == 4:
            visits *= 1.2
        elif weekday == 5:
            visits *= 1.35
        # visitor count is set to -1 on sundays
        elif weekday == 6:
            visits *= 0
            visits -= 1
        return visits
#+end_src

*** get_visit_count method :noexport:
#+begin_src python :tangle src/sensor.py
    def get_visit_count(self, business_date:date, hour:int) -> int:
        """Returns the number of visitors from the store opening hour to the hour passed in parameters."""
        #For reprocubility
        np.random.seed(seed=business_date.toordinal())

        visitors_count = 0
        proba_malfunction = np.random.random()

        # The sensor can break sometimes
        # Also return 0 when hour in closing hours
        if proba_malfunction < self.perc_break or hour not in self.open_hours:
           return visitors_count
        if business_date.weekday() == 6:
           return -1
        visits = self.simulate_visit_count(business_date)
        # The sensor can also malfunction
        if proba_malfunction < self.perc_malfunction:
            visits *= 0.2  # make it so bad we can detect it ;)
        visits = np.floor(visits)
        for hour_, visit_count in zip(self.open_hours, visits):
                visitors_count += visit_count
                if hour_==hour:
                        break
        return int(visitors_count)
#+end_src
*** __main__ :noexport:
#+begin_src python :tangle src/sensor.py
if __name__ == "__main__":
    if len(sys.argv) > 2:
        year, month, day = [int(v) for v in sys.argv[1].split("-")]
        hour = int(sys.argv[2])
    else:
        year, month, day = 2023, 10, 25
        hour = 18
    queried_date = date(year, month, day)

    captor = Sensor(1500, 150)
    print(captor.get_visit_count(queried_date, hour))
#+end_src
** Unit tests :noexport:
#+begin_src python :tangle tests/test_sensors.py
import unittest
from datetime import date

import numpy as np
from data_quality_monitoring.src.sensor import Sensor

class TestVisitSensor(unittest.TestCase):
    def test_weekdays_open(self):
        for test_day in range(11, 17):
            with self.subTest(i=test_day):
                visit_sensor = Sensor(1200, 300)
                visit_count = visit_sensor.simulate_visit_count(date(2023, 9, test_day))
                self.assertFalse(-1 in set(visit_count))

    def test_sunday_closed(self):
        visit_sensor = Sensor(1200, 300)
        visit_count = visit_sensor.simulate_visit_count(date(2023, 9, 17))
        self.assertEqual(set(visit_count), {-1})

    def test_with_break(self):
        visit_sensor = Sensor(1500, 150, perc_break=15)
        visit_count = visit_sensor.get_visit_count(date(2023, 10, 12), 20)
        self.assertEqual(visit_count, 0)

    def test_with_malfunction(self):
        visit_sensor = Sensor(1500, 150, perc_malfunction=15)
        visit_count = visit_sensor.get_visit_count(date(2023, 10, 12), 20)
        self.assertEqual(visit_count, 276)


if __name__ == "__main__":
    unittest.main()


#+end_src
* API
- Creation of an api with FastAPI
#+begin_src python :tangle app.py
import logging
from datetime import date

from fastapi import FastAPI
from fastapi.responses import JSONResponse
from src.sensor import Sensor

sensor = Sensor(5000, 750)
app = FastAPI()


@app.get("/")
def get_nb_visitors(year: int, month: int, day: int, hour: int = 21) -> JSONResponse:
    # Check the year
    if year < 2020:
        return JSONResponse(status_code=404, content="No data before 2020")

    # Check the date
    try:
        requested_date = date(year, month, day)
    except ValueError as e:
        logging.error(f"Could not cast date: {e}")
        return JSONResponse(status_code=404, content="Enter a valid date")

    # Check the date is in the past
    if date.today() < requested_date:
        return JSONResponse(status_code=404, content="Choose a date in the past")
    if hour > max(sensor.open_hours):
        visit_counts = sensor.get_visit_count(requested_date, 21)
    else:
        visit_counts = sensor.get_visit_count(requested_date, hour)
    if visit_counts < 0 or hour < min(sensor.open_hours):
        return JSONResponse(
            status_code=404, content="The store was closed try another date or hour."
        )
    return JSONResponse(status_code=200, content=visit_counts)
#+end_src
